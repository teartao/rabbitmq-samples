# RabbitMQ 快速入门


## RabbitMQ是什么？

RabbitMQ 是当前热门的消息队列中间件之一。

## RabbitMQ主要特点

根据定义（Message Queue）可知它是个具有**先进先出**特点的消息存储中间件，可以理解为存储消息的容器。生产者只需将消息放入该容器中，而无需关心消费者如何处理消息。同时消息可以由多个生产者存入中间件，也可以由多个消费者去获取并处理。同时生产者并不知道消费者何时处理消息，因此它还具有异步的特性。

总结一下主要特点：

- 阻塞&有序：通过先进先出维护一个阻塞的有序队列
- 中间件容器：在分布式环境下使用，用于多应用间通信
- 异步：生产者将消息丢入容器即可，不再关心消费者何时处理

## 使用RabbitMQ主要目的

通过上述特点，便可以理解MQ常见的使用目的：

- **解耦：**维护了生产者-> 中间件  和 中间件->消费者的关系，让生产者和消费者没有直接的调用关系，仅需关心各自的发/收的数据结构即可，达到程序解耦的目的。
- **削峰：**当生产者收到大量请求时，生产消息丢给mq无需立即处理(立刻响应，慢慢处理)。且可以增加消费者数量，来分摊处理生产者生产的的消息。通过异步和负载均衡分流思路，来解决生产者需要及时处理大量请求的问题，以达到削峰的目的。

由于RabbitMQ 还具备有序、消息通信等特点，因此还可以用来解决一些业务处理顺序的问题，也可以作为分布式环境的数据传输/存储中间件，但是这么用的话，就会显得比较"骚"了，因为想要使用这些特点时候，都有更好的中间件产品可以选择。



## RabbitMQ使用场景







## 为什么是RabbitMQ

说到这可能有人会好奇：

- 如果是阻塞队列，我为什么不用Java自带的BlockingQueue？为什么要用RabbitMQ？

- 如果是为了异步，我为什么不直接`new Thread(()->{}).start()`？

- 如果是为了通信，为什么不直接使用Http的工具，直接发HTTP请求？

这些疑问都没错。

如果只是为了通过阻塞队列控制代码执行顺序，用BlockingQueue，这当然没问题，也最简单。

如果在单一场景下，仅仅为了异步，且应用本身不存在性能瓶颈，使用new Thread 也没有任何问题。

如果仅仅为了通信，发一个json  字符串 或者其它字节流等信息，也确实没有必要引入RabbitMQ增加复杂度。



可是



